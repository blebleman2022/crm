# 数据丢失隐患分析报告

## 📋 执行摘要

经过全面检查项目代码，发现了**5个高风险隐患**和**3个中风险隐患**，可能导致数据丢失。以下是详细分析和修复建议。

---

## 🚨 高风险隐患

### 1. **外键约束未启用（最严重）**

**问题描述：**
- SQLite数据库的外键约束默认是**关闭**的
- 检查结果显示：`PRAGMA foreign_keys = 0`（未启用）
- 所有外键关系都设置为 `NO ACTION`，没有级联删除保护

**风险影响：**
- ❌ 删除父记录时，子记录不会被自动删除或阻止
- ❌ 可能产生"孤儿数据"（orphaned records）
- ❌ 数据完整性无法保证

**实际案例：**
```python
# 如果删除一个Lead，但Customer仍然引用它
Lead.query.filter_by(id=123).delete()  # Lead被删除
# 但 Customer.lead_id=123 的记录仍然存在，变成孤儿数据
# 访问 customer.lead 时会返回 None，导致错误
```

**修复方案：**
在 `config.py` 中添加：
```python
class BaseConfig:
    SQLALCHEMY_ENGINE_OPTIONS = {
        'connect_args': {
            'check_same_thread': False,
        },
        'pool_pre_ping': True,
    }
    
    @staticmethod
    def init_app(app):
        # 启用外键约束
        from sqlalchemy import event
        from sqlalchemy.engine import Engine
        
        @event.listens_for(Engine, "connect")
        def set_sqlite_pragma(dbapi_conn, connection_record):
            cursor = dbapi_conn.cursor()
            cursor.execute("PRAGMA foreign_keys=ON")
            cursor.close()
```

---

### 2. **删除操作缺少级联处理**

**问题位置：** `routes/admin.py` 第583-630行

**问题代码：**
```python
@admin_bp.route('/leads/<int:lead_id>/delete', methods=['POST'])
def delete_lead(lead_id):
    lead = Lead.query.get_or_404(lead_id)
    
    # 手动删除关联数据
    customer = Customer.query.filter_by(lead_id=lead_id).first()
    if customer:
        TutoringDelivery.query.filter_by(customer_id=customer.id).delete()
        CompetitionDelivery.query.filter_by(customer_id=customer.id).delete()
        db.session.delete(customer)
    
    CommunicationRecord.query.filter_by(lead_id=lead_id).delete()
    Payment.query.filter_by(lead_id=lead_id).delete()
    db.session.delete(lead)
    db.session.commit()
```

**风险分析：**
- ✅ 代码逻辑正确，但**依赖手动维护**
- ❌ 如果未来添加新的关联表，容易遗漏
- ❌ 如果删除过程中出现异常，可能导致部分数据删除

**修复建议：**
在 `models.py` 中使用 SQLAlchemy 的 `cascade` 选项：
```python
class Lead(db.Model):
    # 关联关系
    customer = db.relationship('Customer', backref='lead', uselist=False, 
                              cascade='all, delete-orphan')
    payments = db.relationship('Payment', backref='lead', lazy='dynamic',
                              cascade='all, delete-orphan')
    communication_records = db.relationship('CommunicationRecord', backref='lead',
                                           cascade='all, delete-orphan')
```

---

### 3. **事务回滚后状态不一致**

**问题位置：** 多处 `db.session.rollback()` 调用

**问题代码示例：**
```python
try:
    customer.teacher_user_id = teacher_user_id
    db.session.commit()
except Exception as e:
    db.session.rollback()  # 回滚数据库
    # 但 customer 对象的内存状态已经改变！
    return jsonify({'success': False, 'message': str(e)})
```

**风险分析：**
- ❌ 回滚后，Python对象的状态与数据库不一致
- ❌ 后续操作可能基于错误的对象状态
- ❌ 可能导致数据覆盖或丢失

**修复建议：**
回滚后刷新对象状态：
```python
try:
    customer.teacher_user_id = teacher_user_id
    db.session.commit()
except Exception as e:
    db.session.rollback()
    db.session.refresh(customer)  # 刷新对象状态
    return jsonify({'success': False, 'message': str(e)})
```

---

### 4. **并发更新无锁保护**

**问题位置：** `routes/customers.py` 第484-513行

**问题代码：**
```python
@customers_bp.route('/<int:customer_id>/toggle_priority', methods=['POST'])
def toggle_customer_priority(customer_id):
    customer = Customer.query.get_or_404(customer_id)
    is_priority = request.json.get('is_priority', False)
    
    customer.is_priority = is_priority  # 无锁保护
    customer.updated_at = datetime.utcnow()
    db.session.commit()
```

**风险场景：**
```
时间线：
T1: 用户A读取 customer (is_priority=False)
T2: 用户B读取 customer (is_priority=False)
T3: 用户A设置 is_priority=True，提交
T4: 用户B设置 is_priority=False，提交  ← 覆盖了用户A的修改！
```

**修复建议：**
使用乐观锁或悲观锁：
```python
# 方案1：乐观锁（推荐）
customer = Customer.query.filter_by(
    id=customer_id,
    updated_at=request.json.get('last_updated_at')
).first()
if not customer:
    return jsonify({'success': False, 'message': '数据已被其他用户修改，请刷新后重试'})

# 方案2：悲观锁
customer = Customer.query.with_for_update().get(customer_id)
```

---

### 5. **文件删除与数据库不同步**

**问题位置：** `routes/teachers.py` 第403-424行

**问题代码：**
```python
@teachers_bp.route('/delete-image/<int:image_id>', methods=['POST'])
def delete_teacher_image(image_id):
    image = TeacherImage.query.get_or_404(image_id)
    
    # 先删除文件
    filepath = os.path.join('static', image.image_path)
    if os.path.exists(filepath):
        os.remove(filepath)  # 如果这里成功
    
    # 再删除数据库记录
    db.session.delete(image)
    db.session.commit()  # 如果这里失败，文件已被删除但数据库记录还在
```

**风险分析：**
- ❌ 文件删除成功，但数据库提交失败 → 数据库记录指向不存在的文件
- ❌ 数据库删除成功，但文件删除失败 → 磁盘空间浪费，文件泄露

**修复建议：**
调整顺序，先删除数据库记录：
```python
try:
    # 1. 先记录文件路径
    filepath = os.path.join('static', image.image_path)
    
    # 2. 删除数据库记录
    db.session.delete(image)
    db.session.commit()
    
    # 3. 最后删除文件（即使失败也不影响数据一致性）
    if os.path.exists(filepath):
        try:
            os.remove(filepath)
        except Exception as e:
            # 记录日志，但不影响主流程
            print(f"文件删除失败: {filepath}, 错误: {e}")
    
    return jsonify({'success': True, 'message': '图片删除成功'})
except Exception as e:
    db.session.rollback()
    return jsonify({'success': False, 'message': f'删除失败：{str(e)}'}), 500
```

---

## ⚠️ 中风险隐患

### 6. **软删除未完全实现**

**问题位置：** `routes/teachers.py` 第156-181行

**问题描述：**
- Teacher 使用软删除（status=False）
- 但查询时没有过滤 status=False 的记录
- 可能导致"已删除"的老师仍然出现在列表中

**修复建议：**
```python
# 在所有查询中添加过滤
Teacher.query.filter_by(status=True).all()

# 或在模型中添加默认作用域
class Teacher(db.Model):
    __mapper_args__ = {
        'polymorphic_identity': 'teacher',
        'with_polymorphic': '*'
    }
    
    @classmethod
    def active(cls):
        return cls.query.filter_by(status=True)
```

---

### 7. **JSON字段解析错误处理不足**

**问题位置：** `models.py` 第105-113行

**问题代码：**
```python
def get_service_types_list(self):
    if self.service_types:
        try:
            return json.loads(self.service_types)
        except:  # 捕获所有异常，但不记录
            return []
    return []
```

**风险分析：**
- ❌ 静默失败，无法发现数据损坏
- ❌ 可能返回空列表，导致业务逻辑错误

**修复建议：**
```python
def get_service_types_list(self):
    if self.service_types:
        try:
            return json.loads(self.service_types)
        except json.JSONDecodeError as e:
            # 记录错误日志
            import logging
            logging.error(f"Lead {self.id} service_types JSON解析失败: {e}, 原始数据: {self.service_types}")
            return []
    return []
```

---

### 8. **批量操作缺少事务保护**

**问题位置：** `routes/admin.py` 第583-630行

**问题描述：**
- 删除线索时需要删除多个关联表的数据
- 如果中间某步失败，可能导致部分数据删除

**当前代码：**
```python
TutoringDelivery.query.filter_by(customer_id=customer.id).delete()
CompetitionDelivery.query.filter_by(customer_id=customer.id).delete()
db.session.delete(customer)
# 如果这里出错，前面的删除已经执行
CommunicationRecord.query.filter_by(lead_id=lead_id).delete()
```

**修复建议：**
已经有 try-except 包裹，但建议添加更细粒度的检查：
```python
try:
    # 使用 savepoint 保护
    with db.session.begin_nested():
        if customer:
            TutoringDelivery.query.filter_by(customer_id=customer.id).delete()
            CompetitionDelivery.query.filter_by(customer_id=customer.id).delete()
            db.session.delete(customer)
        
        CommunicationRecord.query.filter_by(lead_id=lead_id).delete()
        Payment.query.filter_by(lead_id=lead_id).delete()
        db.session.delete(lead)
    
    db.session.commit()
except Exception as e:
    db.session.rollback()
    return jsonify({'success': False, 'message': f'删除失败：{str(e)}'})
```

---

## 📊 风险等级总结

| 隐患 | 风险等级 | 影响范围 | 修复优先级 |
|------|---------|---------|-----------|
| 1. 外键约束未启用 | 🔴 极高 | 全局 | P0 立即修复 |
| 2. 删除操作缺少级联 | 🔴 高 | Lead/Customer删除 | P0 立即修复 |
| 3. 事务回滚状态不一致 | 🔴 高 | 所有更新操作 | P1 尽快修复 |
| 4. 并发更新无锁保护 | 🔴 高 | 客户信息更新 | P1 尽快修复 |
| 5. 文件删除不同步 | 🔴 高 | 图片删除 | P1 尽快修复 |
| 6. 软删除未完全实现 | 🟡 中 | Teacher查询 | P2 计划修复 |
| 7. JSON解析错误处理 | 🟡 中 | 服务类型读取 | P2 计划修复 |
| 8. 批量操作事务保护 | 🟡 中 | 批量删除 | P2 计划修复 |

---

## 🛠️ 立即行动建议

### 第一步：启用外键约束（最重要）
修改 `config.py`，添加外键约束启用代码。

### 第二步：添加级联删除
修改 `models.py`，在关联关系中添加 `cascade='all, delete-orphan'`。

### 第三步：修复文件删除顺序
修改 `routes/teachers.py`，先删除数据库记录，再删除文件。

### 第四步：添加并发控制
在关键更新操作中添加乐观锁或悲观锁。

### 第五步：完善错误处理
在所有 `db.session.rollback()` 后添加 `db.session.refresh()`。

---

## 📝 数据备份建议

在修复这些隐患之前，强烈建议：

1. **立即备份数据库**
   ```bash
   cp instance/edu_crm.db instance/edu_crm_backup_$(date +%Y%m%d_%H%M%S).db
   ```

2. **启用自动备份**
   项目中已有 `backup_database.sh`，建议设置定时任务：
   ```bash
   # 每天凌晨2点备份
   0 2 * * * /path/to/backup_database.sh
   ```

3. **测试恢复流程**
   定期测试备份文件是否可以成功恢复。

---

## 🔍 监控建议

添加数据完整性检查脚本：

```python
# check_data_integrity.py
from models import db, Lead, Customer, Payment, CommunicationRecord

def check_orphaned_records():
    """检查孤儿数据"""
    issues = []
    
    # 检查Customer是否有无效的lead_id
    orphaned_customers = db.session.query(Customer).filter(
        ~Customer.lead_id.in_(db.session.query(Lead.id))
    ).all()
    if orphaned_customers:
        issues.append(f"发现 {len(orphaned_customers)} 个孤儿Customer记录")
    
    # 检查Payment是否有无效的lead_id
    orphaned_payments = db.session.query(Payment).filter(
        ~Payment.lead_id.in_(db.session.query(Lead.id))
    ).all()
    if orphaned_payments:
        issues.append(f"发现 {len(orphaned_payments)} 个孤儿Payment记录")
    
    return issues

if __name__ == '__main__':
    issues = check_orphaned_records()
    if issues:
        print("⚠️ 数据完整性问题：")
        for issue in issues:
            print(f"  - {issue}")
    else:
        print("✅ 数据完整性检查通过")
```

---

## 📅 修复计划

建议分阶段修复：

**第1周：**
- 启用外键约束
- 修复文件删除顺序
- 添加数据备份

**第2周：**
- 添加级联删除配置
- 完善事务回滚处理
- 添加数据完整性检查

**第3周：**
- 实现并发控制
- 完善软删除逻辑
- 添加监控告警

---

生成时间：2025-10-22
分析人：AI Assistant

